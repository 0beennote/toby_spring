# 3장 템플릿

템플릿이란 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

## 템플릿의 적용

#### 템플릿 메소드 패턴
* 상속을 통해 기능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.
* 상속을 통해 확장을 꾀하기 때문에 관계에 대한 유연성이 떨어진다.

#### 전략 패턴
* 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 패턴이다.
* DI는 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조이다.

#### 중첩 클래스의 종류
* 스태틱 클래스: 독립적으로 오브젝트를 만들 수 있음.
* 멤버 내부 클래스: 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스
* 로컬 클래스: 메소드 레벨에 정의되는 로컬 클래스
* 익명 내부 클래스: 이름을 갖지 않는 클래스

#### 인터페이스를 사용하지 않고 밀접한 관계를 갖는 클래스를 DI에 적용하는 방법
* 빈으로 등록해서 사용하는 방법: 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러나지만, DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 직접 노출된다.
* 수동으로 DI를 하는 방법: 필요에 따라 내부에서 은밀히 DI를 수행하고 그 전략을 외부에는 감출 수 있지만, 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고 DI 작업을 위한 부가적인 코드가 필요하다.
* 상황에 따라 적절하다고 판단되는 방법을 선택해서 사용하고 왜 그렇게 선택했는지에 대한 분명한 이유과 근거가 있어야 한다.

## 템플릿/콜백

#### 템플릿과 콜백
* 템플릿: 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀
* 콜백: 실행되는 것을 목적으로 다른 오브젝특의 메소드에 전달되는 오브젝트를 말한다. 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용한다.
* 템플릿/콜백의 작업 흐름
1. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.
2. 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.

#### 템플릿/콜백과 전략 패턴과의 차이
* 여러 개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다.
* 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 템플릿/콜백의 고유한 특징이다. 클라이언트와 콜백이 강하게 결합된다는 면에서도 일반적인 DI와 조금 다르다.
* 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다.
* 템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결함한 독특한 활용법이다.

#### 템플릿/콜백 적용 과정 예시
1. 고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다.
2. 중복된 코드는 먼저 메소드로 분리하는 간단한 시도를 해본다.
3. 그중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리하도록 만든다.
4. 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 템플릿/콜백 패턴을 적용하는 것을 고려한다.

## 정리
* 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다. 바뀌지 않는 부분은 컨텍스트로, 바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.
* 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
* 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
* 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 만든다.
* 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용한다. 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용해서 직접 DI 해줄 수 있다.
* 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.
* 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.
* 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
* 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수도 있다.
* 템플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다.


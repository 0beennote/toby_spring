## 1장 오브젝트와 의존관계

스프링은 오브젝트를 어떻게 효과적으로 설계하고 구현하고, 사용하고, 이를 개선해나갈 것인가에 대한 명쾌한 기준을 마련해준다.
동시에 스프링은 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 적용할 수 있도록 프레임워크 형태로 제공한다.

### 초난감 DAO
* 예제) 클래스 하나에 기능을 전부 담음.
* 자바빈: setter, getter를 이용하여 데이터를 관리하는 오브젝트 (생성자, 프로퍼티, 메서드로 구성)
* 리플렉션: 컴파일 단계가 아닌 런타임 단계에서 로드된 클래스에 접근하여 생성자, 프로퍼티, 메서드 등에 접근하는 기법

### DAO의 분리

#### 분리와 확장
* 예제) 독립된 메소드를 만들어서 분리함.
* 관심사의 분리: 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체를 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.
* 리팩토링: 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업.

#### 상속을 통한 확장
* 예제) 상하위 클래스로 분리함.
* 디자인 패턴: 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션.
* 템플릿 메소드 패턴: 슈퍼클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법.
* 팩토리 메소드 패턴: 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것.
* 다중상속을 허용하지 않아 추가로 상속을 적용하기 어렵고, 상속을 통한 상하위 클래스의 관계가 밀접하다는 단점이 있다.

### DAO의 확장
* 예제) 별도의 클래스로 만듬.
* 인터페이스: 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다. 접근하는 쪽에서는 오브젝트를 만들떄 사용할 클래스가 무엇인지 몰라도 된다.
* 다형성 - 관계설정 책임의 분리: 클래스 사이의 관계(코드에 다른 클래스 이름이 나타나기 때문에 만들어짐) / 오브젝트 사이의 관계(코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 아용할 수 있음)
* 구현 클래스와의 런타임 오브젝트 의존관계 설정의 책임을 클라이언트에게 전가함.
* 개방 폐쇄 원칙(OCP, Open-Closed Principle): 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
* 객체지향 설계 원칙(SOLID)
1. SRP(The Single Responsibility Principle): 단일 책임 원칙 = 한 클래스는 하나의 책임만 가져야 한다.
2. OCP(The Open Closed Principle): 개방 폐쇄 원칙 = 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
3. LSP(The Liskov Substitution Principle): 리스코프 치환 원칙 = 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
4. ISP(The Interface Segregation Principle): 인터페이스 분리 원칙 = 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
5. DIP(The Dependency Inversion Principle): 의존관계 역전 원칙 = 추상화에 의존해야지, 구체화에 의존하면 안된다.
* 높은 응집도: 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻.
* 낮은 결합도: 하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태.
* 전략 패턴: 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴.

### 제어의 역전(IoC: Inversion of Control)
* 예제) 클라이언트에게 전가한 책임이나 관심사도 분리하자. 관계의 재설정.
* 팩토리: 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 오브젝트. 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.
* 제어의 역전: 프로스램의 제어 흐름 구조가 뒤바뀌는 것.
* 라이브러리: 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
* 프레임워크: 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 에필리케이션 코드를 사용하는 방식이다.(제어의 역전 개념이 적용되어 있어야 프레임워크이다.)

### 스프링의 IoC
* 스프링 빈: 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트(자바빈 또는 엔터프라이즈 자바빈에서 말하는 빈과 비슷한 오브젝트 단위의 애필르케이션 컴포넌트)
* 빈 팩토리: 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트(빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점)
* 애플리케이션 컨텍스트: IoC 방식을 따라 만들어진 일종의 빈 팩토리 / 빈 팩토리의 확장 개념(애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진)
* 애플리케이션은 애플리케이션 컨텍스트와 그 설정정보를 따라 만들어진다.
* 애플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.
* 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리한 모든 오브젝트에 대한 생성과 관계설정을 담당한다.
* 오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점
1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
* 스프링 컨테이너: 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용되는데, 이를 통틀어서 스프링 컨테이너라고 부를 수 있다.

### 싱글톤 레지스트리와 오브젝트 스코프
* 오브젝트의 동일성: 하나의 오브젝트만 존재하고 두 개의 오브젝트 레퍼런스 변수를 갖고 있는 것.
* 오브젝트의 동등성: 두 개의 각기 다른 오브젝트가 메모리상에 존재하는데, 오브젝트의 동등성 기준에 따라 두 오브젝트의 정보가 동등하다고 판단한다.
* 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 빈 오브젝트를 모두 싱글톤으로 만든다.
* 싱글톤 레지스트리: 싱글톤 패턴의 구현 방식이 여러가지 단점이 있기 때문에, 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다.
* 싱글톤 패턴: 어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴.
1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
2. 싱글톤은 테스트하기 힘들다.
3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
4. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
* 싱글톤 레지스트리는 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다.
* 싱글톤은 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다.
* 스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위.
* 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 가진다.

### 의존관계 주입(DI)
* 스프링이 제공하는 IoC 방식의 핵심을 짚어주는 의존관계 주입(Dependency Injection)이라는 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했다. (DI 컨테이너)
* 의존관계: B가 변하면 A에 영향을 미친다. 명확한 방향성이 있다.
* 의존 오브젝트: 프로그램이 시작되고 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트.
* 의존관계 주입 충족 조건
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. (인터페이스에만 의존)
2. 런타임 시점의 의존ㄴ관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
* 의존관계 검색(Dependency Lookup): 런타임시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 스스로 컨테이너에게 요청하는 방법.
* 의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없지만, 의존관계 주입에서는 DI를 원하는 오브젝트 자신이 컨테이너가 관리하는 빈이 돼야 한다.
* DI 받는다: 다이나믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입의 파라미터를 통해 이뤄져야 한다.
* 의존관계 주입의 방법
1. 생성자를 이용한 주입
2. 수정자 메소드(setter)를 이용한 주입 / 가장 빈번함
3. 일반 메소드를 이용한 주입

### XML을 이용한 설정
* XML을 이용한 설정의 장점
1. 단순한 텍스트 파일이기 때문에 다루기 쉽다.
2. 쉽게 이해할 수 있으며 컴파일과 같은 별도의 빌드 작업이 없다.
3. 환경이 달라져서 오브젝트의 관계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다.
4. 스키마나 DTD를 이용해서 정해진 포맷을 따라 작성됐는지 손쉽게 확인할 수 있다.
* @Configuration=<beans>, @Bean=<bean>
* 빈의 DI 정보
1. 빈의 이름(id): @Bean 메소드 이름
2. 빈의 클래스(class): 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의.
3. 빈의 의존 오브젝트(property): 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다.
* 자바빈의 관례를 따라서 수정자 메소드는 프로퍼티가 된다.
1. name: 프로퍼티의 이름(set을 제외한 setter 메소드의 명)
2. ref: 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름
3. value: 레퍼런스가 아닌 단순 값을 주입할 때 쓰는 애트리뷰트. 수정자 메소드의 파라미터 타입을 참고하여 형번환을 해준다.
  
### 정리
#### 1장 과정
1. 책임이 다른 코드를 분리해서 두 개의 클래스를 만듬(관심사의 분리, 리팩토링)
2. 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하고, 다른 클래스에서 인터페이스를 통해서만 접근하도록 만듬(전략 패턴)
3. 불필요한 변화를 막고 외부 오브젝트의 기능은 자유롭게 확장 가능(개방 폐쇄 원칙)
4. 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않고(낮은 결합도) 책임과 관심사에만 집중하는(높은 응집도) 코드
5. 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭도록 작업의 제어권을 오브젝트 팩토리 또는 IoC 컨테이너에 넘김(제어의 역전/IoC)
6. 서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용(싱글톤 레지스트리)
7. 설계시점에는 느슨한 의존관계만 만들고, 런타임시에 구체적인 의존 오브젝트를 제 3자에게 주입 받음(의존관계 주입/DI)
8. 생성자 주입과 수정자 주입
9. XML을 이용한 DI 설정정보

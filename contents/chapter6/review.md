# 6장 AOP

## 다이내믹 프록시와 팩토리 빈

### 프록시와 프록시 패턴, 데코레이터 패턴

#### 프록시
* 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다.
* 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.
* 프록시는 타깃과 같은 인터페이스를 구현하며 프록시가 타깃을 제어할 수 있는 위치에 있다.
* 프록시의 첫번째 사용 목적은 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다.
* 프록시의 두번째 사용 목적은 타깃에 부가적인 기능을 부여해주기 위해서다.

#### 데코레이터 패턴
* 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
* 다이내믹하게 기능을 부가한다는 의미는 컴파일 시점에 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다.
* 장식을 붙이는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해주므로 데코레이터라고 불린다.
* 프록시가 꼭 한 개로 제한되지 않으며 직접 타깃을 사용하도록 고정시킬 필요도 없다.
* 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 어디로 위임하는지 알지 못한다.
* 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만든다.

#### 프록시 패턴
* 일반적으로 사용하는 프록시라는 용어는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총친한다.
* 프록시 패턴은 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
* 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
* 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다.
* 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
* 또는 원격 오브젝트를 이용하는 경우나 특별한 상황에서 타깃에 대한 접근권한을 제어할때 프록시 패턴을 사용할 수 있다.

### 다이내믹 프록시

#### 프록시의 구성과 프록시 작성의 문제점
* 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.
* 부가기능 코드가 중복될 가능성이 많다.

#### 리플렉션
* 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.
* 런타임시에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출해낼 수 있는 프로그래밍 기법이다.

#### 다이내믹 프록시 적용
* 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
* 다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.
* 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.
* 프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어준다.
* 부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.
* 다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘긴다.
* 타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공한다.
* 리플렉션을 이용해 간단히 위임 코드를 만들어낼 수 있다.

```java
//InvocationHandler 구현 클래스
public class UppercaseHandler implements InvocationHandler {
  Hello target;
  
  public UppercaseHandler(Hello targer) {
    this.target = target;
  }
  
  public Object invoke(Object proxy, Method mehotd, Object[] args) throws Throwable {
    String ret = (String)method.invoke(target, args); // 타깃으로 위임, 인터페이스의 메소드 호출에 모두 적용된다.
    return ret.toUpperCase(); // 부가기능 제공
  }
}

//프록시 생성
Hello proxiedHello = (Hello)Proxy.newProxyInstance(
      getClass().getClassLoader(),  // 동적으로 생성되는 다이내믹 프록시 클래스의 로딩에 사용할 클래스 로더
      new Class[] { Hello.class },  // 구현할 인터페이스
      new UppercaseHandler(new HelloTarget())); // 부가기능과 위임 코드를 담은 InvocationHandler
```

#### 다이내믹 프록시의 확장
* 인터페이스의 메소드가 늘어나도 다이내믹 프록시가 만들어질 때 추가된 메소드가 자동으로 포함될 것이고, 부가기능은 invoke() 메소드에서 처리된다.
* 리플렉션은 매우 유연하고 막강한 기능을 가졌다. ex) 캐스팅
* 타깃의 종류에 상관없이도 적용이 가능하다.

### 다이내믹 프록시를 위한 팩토리 빈

#### 팩토리 빈
* 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈.
* 스프링의 FactoryBean 인터페이스를 구현하는게 가장 간단한 방법이다.
```java
package org.springframework.beans.factory;

public interface FactoryBean<T> {
  T getObject() throws Exception; // 빈 오브젝트를 생성해서 돌려준다.
  Class<? extends T> getObjectType(); // 생성되는 오브젝트의 타입을 알려준다.
  boolean isSingleton();  // getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.
}
```
* FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.
```java
public class MessageFactoryBean implements FactoryBean<Message> {
  String text;
  
  // 오브젝트를 생성할 때 필요한 정보를 팩토리 빈의 프로퍼티로 설정해서 대신 DI받을 수 있게 한다.
  public void setText(String text) {
    this.text = text;
  }
  
  // 실제 빈으로 사용될 오브젝트를 직접 생성한다.
  public Message getObject() throws Exception {
    return Message.newMessage(this.text);
  }
  
  public Class<? extends Message> getObjectType() {
    return Message.class;
  }
  
  // getObject() 메소드가 돌려주는 오브젝트가 싱글톤인지를 알려준다.
  // 이 팩토리 빈은 매번 요청할 때마다 새로운 오브젝트를 만들므로 false로 설정한다.
  // 이것은 팩토리 빈의 동작방식에 관한 설정이고 만들어진 빈 오브젝트는 싱글톤으로 스프링이 관리해줄 수 있다.
  public boolean isSingleton() {
    return false;
  }
}
```
* 스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용한다.

#### 다이내믹 프록시를 만들어주는 팩토리 빈
* 팩토리 빈의 getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수 있다.

### 프록시 팩토리 빈 방식의 장점과 한계

#### 프록시 팩토리 빈의 재사용
* 한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에 상관없이 재사용할 수 있다.

#### 프록시 팩토리 빈 방식의 장점
* 다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
* 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가기능을 부여해줄 수 있으니 부가기능 코드의 중복 문제도 사라진다.
* 다이내믹 프록시에 팩토리 빈을 이용한 DI까지 더해주면 번거로운 다이내믹 프록시 생성코드도 제거할 수 있다.
* DI 설정만으로 다양한 타깃 오브젝트에 적용도 가능하다.

#### 프록시 팩토리 빈의 한계
* 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하려면 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없다.
* 하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때도 XML 설정이 지나치게 늘어난다.
* 프록시 팩토리 빈 개수만큼 InvocationHandler 구현 클래스의 오브젝트가 늘어난다.

## 스프링의 프록시 팩토리 빈

### ProxyFactoryBean
* 스프링의 ProxyFactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.
* ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
* MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받아 싱글톤 빈으로 등록 가능하다.

#### 어드바이스: 타깃이 필요 없는 순수한 부가기능
* MethodInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 담긴 MethodInvocation 오브젝트가 전달된다.
* MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에 MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있다.
* MethodInvocation은 일종의 콜백 오브젝트로, proceed() 메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다.
* ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다.
* ProxyFactoryBean에는 여러 개의 MethodInterceptor를 추가할 수 있다. 하나의 팩토리 빈만으로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다는 뜻이다.
* 어드바이스: 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트
* 인터페이스를 굳이 알려주지 않아도 ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.
* 알아낸 인터페이스를 모두 구현하는 프록시를 만들어준다.

#### 포인트컷: 부가기능 적용 대상 메소드 선정 방법
* 포인트컷: 메소드 선정 알고리즘을 담은 오브젝트
* 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다.
* 어드바이스가 일종의 템플릿이 되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜벡이 되는 전형적인 템플릿/콜백 구조이다.
* 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적인 전략 패턴 구조이다.
* 어드바이저: 어드바이스와 포인트컷을 묶은 오브젝트를 인터페이스 이름을 따서 어드바이저라고 부른다.

## 스프링 AOP

### 자동 프록시 생성

#### 빈 후처리기
* 빈 후처리기는 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.
* 빈 후처리기 자체를 빈으로 등록하여 스프링에 적용한다.
* 빈 후처리기를 이용한 자동 프록시 생성 방법
1) 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.
2) 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
3) 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
4) 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다.
5) 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.

#### 확장된 포인트컷
```java
두 가지 기능을 정의한 Pointcut 인터페이스
public interface Pointcut {
  ClassFilter getClassFilter(); // 프록시를 적용할 클래스인지 확인해준다.
  MethodMatcher getMethodMatcher(); // 어드바이스를 적용할 메소드인지 확인해준다.
}
```
* Pointcut 선정 기능을 모두 적용한다면 먼저 프록시를 적용할 클래스인지 판단하고 나서, 적용 대상 클래스인 경우에는 어드바이스를 적용할 메소드인지 확인하는 식으로 동작한다.

### 포인트컷 표현식을 이용한 포인트컷

#### 포인트컷 표현식
* 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법.
* 대표적으로 사용되는 것은 execution()
* AspectJ 포인트컷 표현식

### AOP란 무엇인가?

#### AOP: 애스펙트 지향 프로그래밍
* 애스펙트: 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈.
* 독립된 측면에 존재하는 애스펙트로 분리한 덕에 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재한다.
* 애스펙트 지향 프로그래밍(AOP): 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법.
* AOP는 OOP를 돕는 보조적인 기술이지 OOP를 완전히 대체하는 새로운 개념은 아니다.
* 애플리케이션을 특정한 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 관점 지향 프로그래밍이라고도 한다.

### AOP 적용기술

#### 프록시를 이용한 AOP
* 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 맡고 있는게 프록시다.
* 스프링 AOP는 프록시 방식의 AOP라고 할 수 있다.

#### 바이트코드 생성과 조작을 통한 AOP
* 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 방법. ex) AspectJ
* 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해진다.
* 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다. (오브젝트의 생성, 필드값의 조회와 조작, 스태틱 초기화 등 다양한 작업에 부가기능을 부여 가능.)
* JVM의 실행 옵션을 변경하거나, 별도의 바이트코드 컴파일러를 사용하거나, 특별한 클래스 로더를 사용하게 하는 등의 번거로운 작업이 필요하다.

### AOP의 용어

* 타깃: 부가기능을 부여할 대상. 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.
* 어드바이스: 타깃에게 제공할 부가기능을 담은 모듈. 오브젝트로 정의하기도 하지만 메소드 레벨에서도 정의할 수도 있다.
* 조인 포인트: 어드바이스가 적용될 수 있는 위치. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐이다.
* 포인트컷: 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈.
* 프록시: 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트.
* 어드바이저: 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트. 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈.
* 애스펙트: OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈이다. 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다. 따라서 클래스와 같은 모듈 정의와 오브젝트와 같은 실체(인스턴스)의 구분이 특별히 없다.

### AOP 네임스페이스
* 스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
* 스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.
1) 자동 프록시 생성기 / DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록
2) 어드바이스 / 부가기능을 구현한 클래스를 빈으로 등록
3) 포인트컷 / AspectJExpressionPointcut을 빈으로 등록&expression 프로퍼티에 포인트컷 표현식 삽입
4) 어드바이저 / DefaultPointcutAdvisor 클래스를 빈으로 등록

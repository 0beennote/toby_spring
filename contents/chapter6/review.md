# 6장 AOP

## 다이내믹 프록시와 팩토리 빈

### 프록시와 프록시 패턴, 데코레이터 패턴

#### 프록시
* 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시라고 부른다.
* 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.
* 프록시는 타깃과 같은 인터페이스를 구현하며 프록시가 타깃을 제어할 수 있는 위치에 있다.
* 프록시의 첫번째 사용 목적은 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서다.
* 프록시의 두번째 사용 목적은 타깃에 부가적인 기능을 부여해주기 위해서다.

#### 데코레이터 패턴
* 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말한다.
* 다이내믹하게 기능을 부가한다는 의미는 컴파일 시점에 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다.
* 장식을 붙이는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해주므로 데코레이터라고 불린다.
* 프록시가 꼭 한 개로 제한되지 않으며 직접 타깃을 사용하도록 고정시킬 필요도 없다.
* 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 어디로 위임하는지 알지 못한다.
* 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만든다.

#### 프록시 패턴
* 일반적으로 사용하는 프록시라는 용어는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총친한다.
* 프록시 패턴은 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.
* 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않고, 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.
* 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다.
* 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.
* 또는 원격 오브젝트를 이용하는 경우나 특별한 상황에서 타깃에 대한 접근권한을 제어할때 프록시 패턴을 사용할 수 있다.

### 다이내믹 프록시

#### 프록시의 구성과 프록시 작성의 문제점
* 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거롭다.
* 부가기능 코드가 중복될 가능성이 많다.

#### 리플렉션
* 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.
* 런타임시에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출해낼 수 있는 프로그래밍 기법이다.

#### 다이내믹 프록시 적용
* 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트다.
* 다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어진다.
* 클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.
* 프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어준다.
* 부가기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.
* 다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke() 메소드로 넘긴다.
* 타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공한다.
* 리플렉션을 이용해 간단히 위임 코드를 만들어낼 수 있다.

```java
//InvocationHandler 구현 클래스
public class UppercaseHandler implements InvocationHandler {
  Hello target;
  
  public UppercaseHandler(Hello targer) {
    this.target = target;
  }
  
  public Object invoke(Object proxy, Method mehotd, Object[] args) throws Throwable {
    String ret = (String)method.invoke(target, args); // 타깃으로 위임, 인터페이스의 메소드 호출에 모두 적용된다.
    return ret.toUpperCase(); // 부가기능 제공
  }
}

//프록시 생성
Hello proxiedHello = (Hello)Proxy.newProxyInstance(
      getClass().getClassLoader(),  // 동적으로 생성되는 다이내믹 프록시 클래스의 로딩에 사용할 클래스 로더
      new Class[] { Hello.class },  // 구현할 인터페이스
      new UppercaseHandler(new HelloTarget())); // 부가기능과 위임 코드를 담은 InvocationHandler
```

#### 다이내믹 프록시의 확장
* 인터페이스의 메소드가 늘어나도 다이내믹 프록시가 만들어질 때 추가된 메소드가 자동으로 포함될 것이고, 부가기능은 invoke() 메소드에서 처리된다.
* 리플렉션은 매우 유연하고 막강한 기능을 가졌다. ex) 캐스팅
* 타깃의 종류에 상관없이도 적용이 가능하다.

### 다이내믹 프록시를 위한 팩토리 빈

#### 팩토리 빈
* 스프링을 대신해서 오브젝트의 생성로직을 담당하도록 만들어진 특별한 빈.
* 스프링의 FactoryBean 인터페이스를 구현하는게 가장 간단한 방법이다.
```java
package org.springframework.beans.factory;

public interface FactoryBean<T> {
  T getObject() throws Exception; // 빈 오브젝트를 생성해서 돌려준다.
  Class<? extends T> getObjectType(); // 생성되는 오브젝트의 타입을 알려준다.
  boolean isSingleton();  // getObject()가 돌려주는 오브젝트가 항상 같은 싱글톤 오브젝트인지 알려준다.
}
```
* FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으로 동작한다.
